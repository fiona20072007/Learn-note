# React Basics

```html
<!-- CDN links -->
<body>
  <script
    crossorigin
    src="https://unpkg.com/react@16/umd/react.development.js"
  ></script>
  <script
    crossorigin
    src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"
  ></script>
  <script src="./app.js"></script>
</body>
```

```js
const title = React.createElement(
  "h1",
  { id: "main-title", title: "This is an title." },
  "my first React element title"
);

const desc = React.createElement("p", null, "my first React element");
```

React does not create actual DOM nodes(actual h1, div, span). For instance, the title element we defined is not a real h1 element. It's actually an object that describes a DOM node. It's an object representation of a DOM node.

The elements that React creates are actually plain JavaScript objects that describe the element you'd like to display to your UI.

```js
ReactDOM.render(title, document.getElementById("root"));
```

This is the function that actually does the creating and updating of the DOM. It's what connects React to the DOM.

The React code we write in app.js will be rendered into this root div. Or in React terms, this is where we will be mounting our React application. Any existing DOM elements inside the root div will be replaced when render is first called. So everything inside the root DOM element gets managed by ReactDOM.render.

You can provide the children as any number of arguments after the props argument. createElement considers anything after the second argument as children.

React never touches the actual DOM directly. It just manages what gets rendered to the DOM and what gets updated via reactDOM.render. It's not until render that the browser creates actual DOM elements like our header and its children. So in other words, it's renders job to interpret the element objects and create DOM nodes out of them.

React only manages what gets rendered to the DOM via ReactDOM.render. It's the job of render() to interpret the element objects and create DOM nodes out of them.

babel-standalone

```html
<script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
```

JSX is an extension to the JavaScript language that uses a markup-like syntax to create React elements.

Now JSX still produces objects that describe a DOM node.

Since JSX is an extension to the JS language, it accepts any valid JavaScript expressions written inside curly braces.

```js
const title = "my first React element";
const desc = "Hi";
const name = "main-title";

const header = (
  <header>
    {/*this is comment*/}
    <h1 className={name}>{title}</h1>
    <p>{desc}</p>
  </header>
);
```

When you use curly braces in JSX, it's called a JSX expression.

---

A component is a piece of UI that you can reuse. Just like you're able to reuse code in JavaScript with functions, a component lets you reuse code that renders a part of your UI. Being able to split your UI code into independent, reusable pieces, and think about each piece in isolation is one the most embraced features of React.

React components are required to begin with an upper case letter.

JSX lets you define your own tags. A JSX tag can not only represent an HTML element (like \<h1>,\<span>, and \<header>), it can also represent a user-defined component.

The capital letter in the tag name is necessary to differentiate custom components from native DOM elements. Second, is that you can use the self closing form of the tag, if the component has no children. Finally, a component's JSX tag is also a function called to React.createElement under the hood.

When a component contains another component, it's called composition. Composing components is a core principle in React. You'll usually have parent components with one or many child components. This gives the parent component the ability to control how its child components are rendered.

ReactDOM.render usually renders your top level element into the DOM.

---

Every React component and element can receive a list of attributes called properties (or props). Props are a core concept in React because it's how you get data into a component. Most of the components in your UI will be configured with props. For example, you'll add functionality to a component, have it behave a certain way, and display its contents with props.

Anytime you pass a prop a value other than a string, like a number or a variable, you should place it between curly braces so that is gets evaluated as a JSX expression.

When you define a component using a function, the function gets one default argument from React, a props object containing a list of props given to the component.

An important detail to remember about props is that they are "read only" (or immutable), which means that a component can only read the props given to it, never change them. The (parent) component higher in the tree owns and controls the property values.

As stated in the React docs:

All React components must act like pure functions with respect to their props.

That way you avoid unintended behavior (or side effects) in your components. Further, React components are similar to "pure" functions in JavaScript. They do not attempt to change their inputs, and always return the same result for the same inputs.

React manages what gets rendered to the DOM. In order for this process to be fast and efficient, React needs a way to quickly know which items were changed, added, or removed. For this, React gives elements a special built-in prop named key. A key is a unique identifier that gives React a way to quickly and reliably identify an element in a list.

And not all React elements need a key prop. Pass a key prop anytime you're creating elements by iterating over an array of items that will be rearranged, added or deleted in your UI. The key will help React identify which items were changed, added or removed from the DOM.

---

In React, "state" is the data you want to track in your app. State is what allows you to create components that are dynamic and interactive, and it's the only data that changes over time.

State itself is a regular JavaScript object with properties that define the pieces of data that change.

Class components offer a more powerful way to build components because they're the only type of components that let you use state.

In JavaScript classes, the extends keyword is used to create a subclass,
or a child of another class. In this case, we're extending from React.Component which is part of React's API for component class definition.

The only method you need to define in a class component is called render.

In class components, props are not accessed through arguments like they are in functional components. Props are a property of the component itself. So "this" refers to the component instance.

So when do you use a class versus a function?

If a component is only receiving input through props and rendering UI, it's best to use a function or a stateless functional component. Functions are a little bit easier to write, read and understand, and you can think of a stateless functional component as just the render method from a class component with props passed in as an argument.

Now when you want to add state, that's when you use a class component. However, you can also create stateless components as classes.

```js
class Counter extends React.Component {
  constructor() {
    super();
    this.state = {
      score: 0
    };
  }
  render() {
    return (
      <div className="counter">
        <button className="counter-action decrement"> - </button>
        <span className="counter-score">{this.state.score}</span>
      </div>
    );
  }
}
```

Inside the constructor, I'll call super in order to call the constructor of the component class that we're extending. And this needs to be done before we can use the this keyword within the constructor.

You can think of the render method in a class component as being a function of not just props, but props and state. In other words, if either props or state changes, React executes the render method to update what gets displayed to the user.

```js
class Counter extends React.Component {
  state = {
    score: 0
  };
  render() {
    return (
      <div className="counter">
        <button className="counter-action decrement"> - </button>
        <span className="counter-score">{this.state.score}</span>
      </div>
    );
  }
}
```

This class properties syntax is a feature of JavaScript that's currently not supported in all browsers. Since we're using the Babel transpiler in our app, we don't have to worry about browser's support. Babel will transpile our code and add a constructor for us behind the scenes.

To make the Counter component interactive, we need to be able to trigger changes to the data in state. We'll first create an event handler that updates state, using React's built-in setState() method. Then we'll give the buttons an onClick event that calls the event handler when clicked.

In objects or classes, "this" usually refers to the parent that owns the method(This should be the counter class).

When you create a class component that extends from React.Component, any custom methods you create are not bound to the component by default. You need to bind your custom methods, so that this refers to the component instance.

arrow functions use what's called a lexical this binding which means that it automatically bind them to the scope in which they are defined.

We know that inside the render method, this refers to the counter component instance. The arrow function is enclosed inside the render method, so it takes on that same context. And the this value inside it will properly point to the counter component instance.

```js
incrementScore() {
    this.setState({
      score: this.state.score + 1
    });
  }
<button onClick={this.incrementScore.bind(this)}> + </button>

---
incrementScore() {
    this.setState({
      score: this.state.score + 1
    });
  }
<button onClick={() => this.incrementScore()}> + </button>

---
incrementScore = () => {
    this.setState({
      score: this.state.score + 1
    });
  }
<button onClick={this.incrementScore}> + </button>
```

Another way to bind an event handler is in the class constructor:

```js
constructor() {
  super();
  this.state = { score: 0 };
  this.incrementScore = this.incrementScore.bind(this);
}
```

Then pass the function to a React event like so:

```js
<button onClick={this.incrementScore}> + </button>
```
